# TCP/IP/UDP
## 一.UDP
### 1.UDP的特点
-	按顺序发送，但并不一定按顺序接收，不保证顺序和丢失问题
-	可以一对一，也可以一对多
-	继承IP的特点，一个一个的发，一个一个的收
-	不会因为网络问题控制是否发送，完全由应用决定
-	使用场景
	-	不需要一对一，可以广播的应用
	-	实时性高，对于丢包不敏感的应用
### 2.场景举例
- 流媒体，直播
- 实时游戏
- 物联网
- 移动通讯


## 二.TCP
### 1.TCP的特点
-	顺序问题，稳重不乱
-	丢包问题，承诺可靠
-	连接维护，有始有终
-	流量控制，把握分寸（商量好窗口大小）
-	拥塞控制，懂得进退（调整窗口大小）
### 2.三次握手
名词解释
- MSL: 报文最大生存时间
-  TTL: 网络包的生存时间（ip头部的值）
- RTT:  一个请求-应答的过程时间
- SYN: 发起连接（请求）
- ACK: 回复（应答）
- RET: 重新连接
- FIN: 结束连接

三次握手的目的：
-	确保双方都准备好可以收发
	-	A发：A有发的能力
	-	B回复：A有发的能力，B有收的能力
	-	A回复：A，B都有收发的能力
-	确认包的seq的id，不从0开始，随时间变化开始的seq的id不一样
![[三次握手.png]]

问题：
- 如果TCP连接过程中，失败怎么办？
	- 前两次重试
	- 最后一次不管，因为接下来是http连接，只要连接上，就可以证明A有收的能力
- 为什么是三次握手？
	- 至少三次，才能证明双方都准备好，有收发能力

### 3.四次挥手
四次挥手的母的
- 收发双方，互相告知，和平分手
- 确保双方，都能接收到已经发送的数据
- 确保客户端的端口分配给其他应用后，不能再接收到原来的数据


- ![[四次挥手.png]]

简单理解
- A：准备结束了
	- 失败，重发
	- 不会再发送http的数据
- B：收到，我这边也要做准备了
	- 失败，重发
	- 不能直接结束，因为可能还存在已发送，未接收的包
- B:  我做好结束的准备了
	- 失败，重发
- A：收到，那我结束了
	- B 接受到后，进入closed状态 ，如果B未收到，那么会重发告诉A准备好结束了，此时A已经离开，所以直接发送RST.
	- A等待两个MSL后，进入closed，目的是让端口空下来，避免重新分配端口后，接收之前的数据
### 4.流量控制
TCP保证可靠，顺序的问题
- 按顺序发送，接收端收到后需要发送确认收到的ACK给发送端
- 发送端收到确认的ACK后，才会发送下一个
- 如果未收到，则需要等待超时，然后重发。超时的时间要大包的往返时间（RTT）,避免丢失的包后续接收到了
- 确认ACK不是每个都会发，而是会应答某个之前的 ID，表示都收到了
- 如果多次重发，那么重发的时间是上一次的两倍。
- 快速重传：如果5，7，8都收到，就可以连续发三次5的ACK确认信号，从而发送端就会马上重发6
![[滑动窗口-发送端.png]]![[接收端-滑动窗口.jpg]]
滑动窗口
- TCP通讯时会根据接收端的滑动窗口大小，调整发送端的宽口。避免没有空间接收，还一直发
- 滑动窗口由小到大是渐渐的，由小变大则不是，当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口，这样可以避免一下突然又满了

### 5.拥塞控制
拥塞控制的目的
- 包丢失
- 超时重传

**为什么要有拥塞控制？**
```
比如TCP连接是一条水管。那么水管中的数据的量为 宽（带宽） * 长（往返的延时）

丢包
	1.水管漏了（网络不好丢包）
	2.水灌满了，继续注水，导致漏了。 发送窗口 > 接收窗口 ，导致处理不过来
	
解决：水管增加缓存，正常时不能注满水，留着缓存的空间存储处理不过来的数据（TCP BBR 拥塞算法）

```
![[拥塞控制-水管模型.png]]


#### TCP慢启动
如果刚开始就发送大量数据，后续数据传输时，可能出现处理不过，导致丢包。
所以TCP在启动连接的时候，逐渐增大窗口，到达较高的峰值时，然后再降下来（峰值的一半），保证收发各占一半，刚好填满管道
![[拥塞控制.jpg]]

#### TCP队头阻塞
TCP需要保证数据的可靠传输，所以当一个包未接收到时，其他的数据包都会存在缓存中等待丢失包的重传。当缓存满了，导致后续后续来的数据，无法被处理，依旧形成阻塞